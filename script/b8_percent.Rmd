---
title: "b8_percent"
author: "Hayato Yoshioka"
date: "2025-10-20"
output: html_document
---

```{r}
require(BGLR)
require(here)
require(ggplot2)
require(reshape2)
require(gridExtra)
library(readr)
library(stringr)
library(ggsci)
library(RAINBOWR)
```


seed
```{r, message =F, include=FALSE}

# save or read the seed
seedIndCsv <-  here("out","seedInd.csv")
if (file.exists(seedIndCsv)) {
  seedInd <- read.csv(seedIndCsv, row.names = 1, header = T)
  seedInd <- c(as.matrix(seedInd))
} else {
  seedInd <- sample(1:500, 10, replace = F)
  write.csv(x = seedInd, file =  here("out","seedInd.csv"))
}

```



data

```{r}
## =========================================================
## セットアップ（CDループはそのまま）
## =========================================================
for (CD in c("W1", "W4")) {

  if (CD == "W4") {
    file_name <- "blup_drought.rds"
  } else if (CD == "W1") {
    file_name <- "blup_control.rds"
  } else {
    stop("CD must be W1 or W4")
  }

  blup_data <- readRDS(here::here("data/blup", file_name))

  pheno.sel.cd <- blup_data$pheno.sel.cd
  var.id       <- blup_data$var.id
  grm.cd       <- blup_data$grm.cd
  plot.id      <- blup_data$plot.id
  com.cd       <- blup_data$com.cd
  met2.cd      <- blup_data$met2.cd
  com2.cd      <- blup_data$com2.cd

  # しきい値セット
  f_list  <- readRDS(here("data","percentile_met_sets_G_COM_BOTH.rds"))
  models  <- names(f_list)               # c("G_MET","COM_MET","BOTH")
  percent <- c("100","50","25","12_5","6_25")
  thresholds <- paste0(percent)          # 後で intersect 用に同名で保持
  n_repeat <- 10
  if (!exists("seedInd")) seedInd <- 1:5

  ## ---------------------------------------------------------
  ## ユーティリティ
  ## ---------------------------------------------------------
  make_random_subsets_with_cov <- function(met_mat, num_met, nrep = 10, seed = NULL) {
    if (!is.null(seed)) set.seed(seed)
    # num_met は named 整数ベクトル（p100, p50,...）を想定
    if (is.list(num_met)) {
      nm_names <- names(num_met)
      counts   <- sapply(num_met, function(x) as.integer(x[1]))
      names(counts) <- nm_names
    } else {
      counts <- num_met
    }
    p <- ncol(met_mat)
    out <- setNames(vector("list", length(counts)), names(counts))

    for (per in names(counts)) {
      k_eff <- min(p, counts[[per]])
      rep_list <- vector("list", nrep)
      for (i in seq_len(nrep)) {
        cols <- sample(colnames(met_mat), size = k_eff, replace = FALSE)
        submat <- met_mat[, cols, drop = FALSE]
        X <- scale(submat, center = TRUE, scale = TRUE)
        covmat <- tcrossprod(X) / ncol(X)
        rep_list[[i]] <- list(cols = cols, submat = submat, cov = covmat)
      }
      out[[per]] <- rep_list
    }
    out
  }

  run_rainbow_cv <- function(Kmat, y_mat, seedInd) {
    common_ids <- intersect(rownames(Kmat), rownames(y_mat))
    stopifnot(length(common_ids) >= 5)
    K <- Kmat[common_ids, common_ids, drop = FALSE]
    y <- y_mat[common_ids, , drop = FALSE]

    # Kの安定化
    if (!is.matrix(K)) K <- as.matrix(K)
    storage.mode(K) <- "double"
    if (any(!is.finite(K))) {
      bad <- unique(which(!is.finite(K), arr.ind = TRUE)[,1])
      keep <- setdiff(seq_len(nrow(K)), bad)
      K <- K[keep, keep, drop = FALSE]
      y <- y[rownames(K), , drop = FALSE]
    }
    K <- (K + t(K)) / 2
    ev <- suppressWarnings(eigen(K, symmetric = TRUE, only.values = TRUE)$values)
    if (min(ev, na.rm = TRUE) < 0) {
      K <- as.matrix(Matrix::nearPD(K, keepDiag = TRUE)$mat)
    }

    # y 数値化
    y <- as.data.frame(y)
    if (ncol(y) < 2) stop("y must have ID + >=1 trait columns")
    for (j in 2:ncol(y)) y[[j]] <- suppressWarnings(as.numeric(y[[j]]))
    ok_trait <- vapply(2:ncol(y), function(i) sum(is.finite(y[[i]])) >= 5, logical(1))
    if (!all(ok_trait)) {
      y <- y[, c(TRUE, ok_trait), drop = FALSE]
      if (ncol(y) < 2) stop("All traits removed due to too many NAs")
    }

    amatZ <- RAINBOWR::design.Z(pheno.labels = rownames(y), geno.names = rownames(K))
    ZETA  <- list(list(Z = amatZ, K = K))
    X0    <- NULL

    rep5 <- rep(1:5, length.out = nrow(y))
    cor_by_seed <- vector("list", ncol(y) - 1)
    names(cor_by_seed) <- colnames(y)[2:ncol(y)]

    for (i in 2:ncol(y)) {
      y_full <- y[[i]]
      cor_vec <- rep(NA_real_, length(seedInd)); names(cor_vec) <- seedInd
      for (s in seq_along(seedInd)) {
        set.seed(seedInd[s])
        crossCvInd <- sample(rep5, nrow(y), replace = FALSE)
        pred <- rep(NA_real_, nrow(y))
        for (fold in 1:5) {
          testInd <- (crossCvInd == fold)
          yNa <- y_full; yNa[testInd] <- NA
          if (all(is.na(yNa))) next
          resEM3 <- RAINBOWR::EM3.cpp(y = yNa, X0 = X0, n.core = 1, ZETA = ZETA)
          pred[testInd] <- resEM3$y.pred[testInd]
        }
        if (!all(is.na(pred))) {
          cor_vec[s] <- suppressWarnings(cor(y_full, pred, use = "pairwise.complete.obs"))
        }
      }
      cor_by_seed[[colnames(y)[i]]] <- cor_vec
    }

    do.call(rbind, lapply(names(cor_by_seed), function(tr) {
      x <- cor_by_seed[[tr]]
      data.frame(trait = tr,
                 cor_mean = mean(x, na.rm = TRUE),
                 cor_var  = stats::var(x,  na.rm = TRUE),
                 row.names = NULL)
    }))
  }

  summarize_over_repeats <- function(summary_list) {
    lapply(summary_list, function(rep_list) {
      df <- do.call(rbind, lapply(seq_along(rep_list), function(r) {
        cbind(rep = r, rep_list[[r]])
      }))
      agg <- do.call(rbind, lapply(split(df, df$trait), function(dd) {
        data.frame(
          trait         = unique(dd$trait),
          cor_mean_mean = mean(dd$cor_mean, na.rm = TRUE),
          cor_mean_var  = var(dd$cor_mean,  na.rm = TRUE),
          cor_var_mean  = mean(dd$cor_var,  na.rm = TRUE),
          n_rep         = nrow(dd)
        )
      }))
      rownames(agg) <- NULL
      agg
    })
  }

  ## =========================================================
  ## 1) モデルごとに「固定K」を構築（randomはこの後に一度だけ作成）
  ## =========================================================
  fixed_covs <- setNames(vector("list", length(models)), models)  # fixed_covs[[model]][[per]] = K
  fixed_counts <- setNames(vector("list", length(models)), models) # しきい値ごとの列数（random基準用にメモ）

  for (model in models) {
    met2_sub_list <- list()

    for (per in percent) {
      thr_name <- paste0("p", per)
      if (per == "100") {
        met2.cd.sub <- met2.cd
      } else {
        selected_features <- if (CD == "W4") {
          f_list[[model]][[thr_name]]$drought
        } else {
          f_list[[model]][[thr_name]]$control
        }
        cols_to_keep <- intersect(colnames(met2.cd), selected_features)
        met2.cd.sub  <- met2.cd[, cols_to_keep, drop = FALSE]
      }
      met2_sub_list[[per]] <- met2.cd.sub
    }

    # 共分散に変換
    cov_list <- lapply(met2_sub_list, function(submat) {
      if (is.null(submat) || ncol(submat) == 0) return(NULL)
      X <- scale(submat, center = TRUE, scale = TRUE)
      tcrossprod(X) / ncol(X)
    })
    fixed_covs[[model]] <- cov_list
    fixed_counts[[model]] <- lapply(met2_sub_list, ncol)

    # （確認）必要なら
    # print(model); print(CD); print(lapply(met2_sub_list, dim))
  }

  ## =========================================================
  ## 2) ランダムKは「一回だけ」作る
  ##    しきい値ごとの列数は基準モデル（デフォ: BOTH）に合わせる
  ## =========================================================
  random_ref_model <- if ("BOTH" %in% models) "BOTH" else models[[1]]
  num_met_for_random <- fixed_counts[[random_ref_model]]
  names(num_met_for_random) <- names(fixed_covs[[random_ref_model]])  # "100","50",...

  rand_met2_list <- make_random_subsets_with_cov(
    met_mat = met2.cd,
    num_met = num_met_for_random,
    nrep    = n_repeat,
    seed    = 123
  )
  # 使いやすいように cov だけを同じ形にしておく
  rand_covs <- lapply(rand_met2_list, function(rep_list) {
    lapply(rep_list, function(x) x$cov)
  })
  # rand_covs[[per]][[rep]] = K_rand

  ## =========================================================
  ## 3) 4候補（固定3＋RANDOM）× しきい値 × 繰返し で評価
  ## =========================================================
  candidates <- c(models, "RANDOM")

  # 結果入れ物：cor_summary[[candidate]][[per]][[rep_idx]] = data.frame(...)
  cor_summary <- setNames(vector("list", length(candidates)), candidates)
  for (cand in candidates) {
    cor_summary[[cand]] <- setNames(vector("list", length(percent)), percent)
    for (per in percent) {
      cor_summary[[cand]][[per]] <- vector("list", n_repeat)
    }
  }

  for (rep_idx in 1:n_repeat) {
    message("==== Repeat: ", rep_idx, " / ", n_repeat, " ====")

    for (per in percent) {

      # 候補ごとにKを用意
      K_list <- list(
        G_MET   = fixed_covs[["G_MET"]][[per]],
        COM_MET = fixed_covs[["COM_MET"]][[per]],
        BOTH    = fixed_covs[["BOTH"]][[per]],
        RANDOM  = rand_covs[[per]][[rep_idx]]
      )

      for (cand in candidates) {
        Kmat <- K_list[[cand]]

        if (is.null(Kmat)) {
          warning("K is NULL at candidate=", cand, ", per=", per, ", rep=", rep_idx, ". Skip.")
          next
        }

        # 共有サンプル
        common_ids <- intersect(rownames(pheno.sel.cd), rownames(Kmat))
        if (length(common_ids) < 5) {
          warning("Too few common samples at candidate=", cand, ", per=", per, ", rep=", rep_idx, ". Skip.")
          next
        }

        y_sub <- pheno.sel.cd[common_ids, , drop = FALSE]
        K_al  <- as.matrix(Kmat[common_ids, common_ids, drop = FALSE]); storage.mode(K_al) <- "double"

        res <- run_rainbow_cv(K_al, y_sub, seedInd)
        cor_summary[[cand]][[per]][[rep_idx]] <- res
      }
    }
  }

  ## =========================================================
  ## 4) しきい値ごとに 10 回分を要約（各候補で）
  ## =========================================================
  cor_summary10 <- lapply(cor_summary, summarize_over_repeats)

  ## =========================================================
  ## 5) 保存
  ##   - per_repeat: 候補→しきい値→繰返しの生結果
  ##   - summary10 : 候補→しきい値ごとの集約（cor_mean_mean など）
  ## =========================================================
  saveRDS(
    list(
      per_repeat = cor_summary,   # list[candidate][[per]][[rep]] -> data.frame
      summary10  = cor_summary10  # list[candidate][[per]]        -> data.frame
    ),
    here::here("out", paste0("rainbow_cor_summary_", CD, "_4cands.rds"))
  )
}

```



read
```{r, message =F,include=FALSE}
cor_all<-readRDS(here::here("out", paste0("rainbow_cor_summary_", CD, "_4cands.rds")))

cor_all$summary10


```

ONLY ONCE
```{}
## =========================
## 普通のGBLUP（grm.cd）でCV
## =========================

# 1) サンプルIDを合わせる
rownames(grm.cd)<-rownames(pheno.sel.cd)
colnames(grm.cd)<-rownames(pheno.sel.cd)
common_ids <- intersect(rownames(grm.cd), rownames(pheno.sel.cd))
stopifnot(length(common_ids) >= 5)

K_g <- grm.cd[common_ids, common_ids, drop = FALSE]
y_g <- pheno.sel.cd[common_ids, , drop = FALSE]

# 2) K の安全化（対称化・半正定性の確保）
K_g <- as.matrix(K_g); storage.mode(K_g) <- "double"
K_g <- (K_g + t(K_g)) / 2
ev  <- suppressWarnings(eigen(K_g, symmetric = TRUE, only.values = TRUE)$values)
if (min(ev, na.rm = TRUE) < 0) {
  K_g <- as.matrix(Matrix::nearPD(K_g, keepDiag = TRUE)$mat)
}

# 3) 既存の run_rainbow_cv() をそのまま使用
#    （seedInd はあなたのコードで準備済み）
res_gblup <- run_rainbow_cv(Kmat = K_g, y_mat = y_g, seedInd = seedInd)

# 4) 保存
dir.create(here::here("out", "gblup_cv", CD), recursive = TRUE, showWarnings = FALSE)
saveRDS(res_gblup, here::here("out", paste0("gblup_cv_", CD, ".rds")))
# write.csv(res_gblup, here::here("out", "gblup_cv", CD, paste0("gblup_", CD, ".csv")),
#           row.names = FALSE)

# 5) （任意）既存の結果オブジェクトにマージして、後で一緒に図示/比較しやすく
#    例：固定K（しきい値）との横並び比較のために名前を付けてリスト化
gblup_summary <- res_gblup # 列: trait, cor_mean, cor_var

```


memo (proto)

```{}


for (CD in c("W1", "W4")){
  

if (CD == "W4") {
  file_name <- "blup_drought.rds"
} else if (CD == "W1") {
  file_name <- "blup_control.rds"
} else {
  stop("CD must be W1 or W4")
}

blup_data <- readRDS(here::here("data/blup", file_name))


pheno.sel.cd <- blup_data$pheno.sel.cd
var.id       <- blup_data$var.id
grm.cd       <- blup_data$grm.cd
plot.id      <- blup_data$plot.id
com.cd       <- blup_data$com.cd
met2.cd      <- blup_data$met2.cd
com2.cd     <- blup_data$com2.cd

# threshold_metabo.rds の読み込み
f_list <- readRDS(here("data","percentile_met_sets_G_COM_BOTH.rds"))

# すべてのthreshold
percent <- c("100","50","25","12_5","6_25")

# 結果を入れるリスト
met2_sub_list <- list()

models <-  names(f_list)

for (model in models){
  

for (per in percent) {
  # threshold名を組み立て
  thr_name <- paste0("p", per)
  
  if(per == "100"){
    met2.cd.sub<-met2.cd
  } else {
    # drought or controlで対象ベクトルを選択
    selected_features <- if (CD == "W4") {
      f_list[[model]][[thr_name]]$drought
    } else if (CD == "W1") {
      f_list[[model]][[thr_name]]$control
    } else {
      stop("CD は 'W1' または 'W4' である必要があります。")
    }
    
    # met2.cdとの共通部分
    cols_to_keep <- intersect(colnames(met2.cd), selected_features)
    
    # 該当列だけ抽出
    met2.cd.sub <- met2.cd[, cols_to_keep, drop = FALSE]
  }
  
  print(dim(met2.cd.sub))

  # リストに格納
  met2_sub_list[[per]] <- met2.cd.sub
  
}
  
 # ✅ リストの中身を確認
names(met2_sub_list)
num_met<-lapply(met2_sub_list, ncol)

## 1) met2_sub_list を作った後：共分散を作成
cov_list <- lapply(met2_sub_list, function(submat) {
  if (is.null(submat) || ncol(submat) == 0) return(NULL)
  X <- scale(submat, center = TRUE, scale = TRUE)  # 平均中心化
  tcrossprod(X) / (ncol(X))                     # 共分散（サンプル×サンプル）
})

## 2) サブセットと共分散をひとまとめにしたバンドルを作成
met2_sub_cov_bundle <- list(
  subsets = met2_sub_list,  # 各thresholdの抽出行列
  covs    = cov_list        # 各thresholdの共分散行列
)

## 3) まとめてRDS保存
#saveRDS(met2_sub_cov_bundle, here::here("data", "met2_sub_cov_bundle.rds"))

## 4) （任意）しきい値ごとに個別保存したい場合
# dir.create(here::here("data", "met2_sub_cov"), recursive = TRUE, showWarnings = FALSE)

# for (per in names(met2_sub_list)) {
#   submat <- met2_sub_list[[per]]
#   covmat <- cov_list[[per]]
#   obj <- list(submat = submat, cov = covmat)
#   thr_sanitized <- gsub("\\.", "_", per)  # ファイル名にドットがあるときのケア
#   saveRDS(obj, here::here("data", "met2_sub_cov", paste0("met2_", thr_sanitized, ".rds")))
# }

## 5) 確認（例）
names(met2_sub_cov_bundle$subsets)
lapply(met2_sub_cov_bundle$covs, function(x) if (is.null(x)) NA else dim(x))

print(model)
print(CD)




####Phenotyope Rainbowr



  

make_random_subsets_with_cov <- function(met_mat, num_met, nrep = 10, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)

  # num_met を named ベクトルにしておく（list の場合も対応）
  if (is.list(num_met)) {
    nm_names <- names(num_met)
    counts   <- sapply(num_met, function(x) as.integer(x[1]))
    names(counts) <- nm_names
  } else {
    counts <- num_met
  }

  p <- ncol(met_mat)
  n <- nrow(met_mat)

  out <- list()

  for (per in names(counts)) {
    k <- counts[[per]]
    # 列数を超えないようにガード（超える場合は全列）
    k_eff <- min(p, k)

    thr_list <- vector("list", nrep)

    for (i in seq_len(nrep)) {
      # 列名から無作為抽出（非復元）
      cols <- sample(colnames(met_mat), size = k_eff, replace = FALSE)

      # サブセット
      submat <- met_mat[, cols, drop = FALSE]
      # 共分散（平均中心化 → tcrossprod / (n-1)）
      X <- scale(submat, center = TRUE, scale = T)
      covmat <- tcrossprod(X) / ncol(X)

      thr_list[[i]] <- list(
        cols   = cols,     # 使った列名
        submat = submat,   # 抽出したサブ行列
        cov    = covmat    # 共分散行列
      )
    }

    out[[per]] <- thr_list
  }

  out
}

rand_met2_list <- make_random_subsets_with_cov(
  met_mat = met2.cd,
  num_met = num_met,
  nrep    = 10,
  seed    = 123  # 再現性が欲しければ
)


## ========= 準備 =========
# y: 表現型 (サンプル×traits) 例: y <- pheno.sel.cd
# seedInd: CVの乱数シードの集合（ユーザ環境に合わせて）
if (!exists("seedInd")) seedInd <- 1:5

# 使うしきい値の並び（met2_sub_cov_bundle$covs と rand_met2_list のキーが一致している前提）
thresholds <- intersect(names(met2_sub_cov_bundle$covs), names(rand_met2_list))

thresholds <- thresholds[1:5]
# 評価指標（今回は correlation の mean / var を集計）
metric_name <- c("cor_mean", "cor_var")

## ========= ヘルパー関数 =========
run_rainbow_cv <- function(Kmat, y_mat, seedInd) {
  common_ids <- intersect(rownames(Kmat), rownames(y_mat))
  stopifnot(length(common_ids) >= 5)
  K <- Kmat[common_ids, common_ids, drop = FALSE]
  y <- y_mat[common_ids, , drop = FALSE]

  # --- K 安全化 ---
  if (!is.matrix(K)) K <- as.matrix(K)
  storage.mode(K) <- "double"
  if (any(!is.finite(K))) {
    bad <- unique(which(!is.finite(K), arr.ind = TRUE)[,1])
    keep <- setdiff(seq_len(nrow(K)), bad)
    K <- K[keep, keep, drop = FALSE]
    y <- y[rownames(K), , drop = FALSE]
  }
  K <- (K + t(K)) / 2
  ev <- suppressWarnings(eigen(K, symmetric = TRUE, only.values = TRUE)$values)
  if (min(ev, na.rm = TRUE) < 0) {
    K <- as.matrix(Matrix::nearPD(K, keepDiag = TRUE)$mat)
  }

  # --- y 数値化（ここが今回のキモ）---
  y <- as.data.frame(y)
  if (ncol(y) < 2) stop("y must have ID + >=1 trait columns")
  for (j in 2:ncol(y)) y[[j]] <- suppressWarnings(as.numeric(y[[j]]))

  # 元NAが多すぎる trait は除外（必要なら閾値調整）
  ok_trait <- vapply(2:ncol(y), function(i) sum(is.finite(y[[i]])) >= 5, logical(1))
  if (!all(ok_trait)) {
    y <- y[, c(TRUE, ok_trait), drop = FALSE]
    if (ncol(y) < 2) stop("All traits removed due to too many NAs")
  }

  # --- RAINBOWR 準備 ---
  amatZ <- RAINBOWR::design.Z(pheno.labels = rownames(y), geno.names = rownames(K))
  ZETA  <- list(list(Z = amatZ, K = K))
  X0    <- NULL

  rep5 <- rep(1:5, length.out = nrow(y))
  cor_by_seed <- vector("list", ncol(y) - 1)
  names(cor_by_seed) <- colnames(y)[2:ncol(y)]

  for (i in 2:ncol(y)) {
    trait.name <- colnames(y)[i]
    y_full <- y[[i]]
    cor_vec <- rep(NA_real_, length(seedInd)); names(cor_vec) <- seedInd

    for (s in seq_along(seedInd)) {
      set.seed(seedInd[s])
      crossCvInd <- sample(rep5, nrow(y), replace = FALSE)
      pred <- rep(NA_real_, nrow(y))

      for (fold in 1:5) {
        testInd <- (crossCvInd == fold)
        yNa <- y_full; yNa[testInd] <- NA
        if (all(is.na(yNa))) next
        resEM3 <- RAINBOWR::EM3.cpp(y = yNa, X0 = X0, n.core = 1, ZETA = ZETA)
        pred[testInd] <- resEM3$y.pred[testInd]
      }
      if (!all(is.na(pred))) {
        cor_vec[s] <- suppressWarnings(cor(y_full, pred, use = "pairwise.complete.obs"))
      }
    }
    cor_by_seed[[trait.name]] <- cor_vec
  }

  do.call(rbind, lapply(names(cor_by_seed), function(tr) {
    x <- cor_by_seed[[tr]]
    data.frame(trait = tr,
               cor_mean = mean(x, na.rm = TRUE),
               cor_var  = stats::var(x,  na.rm = TRUE),
               row.names = NULL)
  }))
}

## ========= 実験本体（10回） =========
n_repeat <- 10

# しきい値 × 繰り返し で、固定K/ランダムKの結果を入れるリスト
cor_summary_fixed <- setNames(vector("list", length(thresholds)), thresholds)
cor_summary_rand  <- setNames(vector("list", length(thresholds)), thresholds)

for (per in thresholds) {
  cor_summary_fixed[[per]] <- vector("list", n_repeat)
  cor_summary_rand[[per]]  <- vector("list", n_repeat)
}

for (rep_idx in 1:n_repeat) {
  message("==== Repeat: ", rep_idx, " / ", n_repeat, " ====")

  for (per in thresholds) {
    # --- K（固定）と K（ランダム）を取得 ---
    K_fixed <- met2_sub_cov_bundle$covs[[per]]
K_rand  <- rand_met2_list[[per]][[rep_idx]]$cov

# 型と数値化（疎行列→dense）
K_fixed <- as.matrix(K_fixed); storage.mode(K_fixed) <- "double"
K_rand  <- as.matrix(K_rand);  storage.mode(K_rand)  <- "double"



    if (is.null(K_fixed) || is.null(K_rand)) {
      warning("K is NULL at per=", per, ", rep=", rep_idx, ". Skip.")
      next
    }

    # --- サンプル合わせ（固定KとランダムKと表現型の共通サンプルを使う） ---
# --- 共通サンプル ---
common_ids <- Reduce(intersect, list(rownames(pheno.sel.cd),
                                     rownames(K_fixed),
                                     rownames(K_rand)))

    if (length(common_ids) < 5) { # 最低限の数を確保（適宜変更）
      warning("Too few common samples at per=", per, ", rep=", rep_idx, ". Skip.")
      next
    }
    y_sub      <- pheno.sel.cd[common_ids, , drop = FALSE]
    K_fixed_al <- K_fixed[common_ids, common_ids, drop = FALSE]
    K_rand_al  <- K_rand [common_ids, common_ids,  drop = FALSE]

    # --- RAINBOWR CV を実行：固定K ---
    res_fixed <- run_rainbow_cv(K_fixed_al, y_sub, seedInd)
    # --- RAINBOWR CV を実行：ランダムK ---
    res_rand  <- run_rainbow_cv(K_rand_al,  y_sub, seedInd)

    # 保存（trait × {cor_mean, cor_var} の data.frame）
    cor_summary_fixed[[per]][[rep_idx]] <- res_fixed
    cor_summary_rand [[per]][[rep_idx]] <- res_rand
  }
}

## ========= しきい値ごとに10回分をまとめ（平均・分散をさらに要約したければ） =========
# 例：各しきい値 × trait で cor_mean の平均・分散を出す
aggregate_cor_summary <- function(summary_list) {
  # summary_list[[per]][[rep]]: data.frame(trait, cor_mean, cor_var)
  out <- lapply(summary_list, function(rep_list) {
    # traitで bind
    all_df <- Reduce(function(a, b) merge(a, b, by = "trait", all = TRUE,
                                          suffixes = c("", "")),
                     rep_list)
    # 列名が trait, cor_mean, cor_var, cor_mean, cor_var, ... になるので整理
    # repごとの cor_mean だけを抜き出して集計
    mean_cols <- grep("^cor_mean$", names(all_df))
    var_cols  <- grep("^cor_var$",  names(all_df))
    # 列名が重複しないよう merge ではなく rbind＋split の方が安全だが、
    # シンプルに lapply で積み上げる方式に変更
    NULL
  })
  # 上は柔軟に作るならもう少し手当が必要。実務では下の安全版を推奨。
  # 安全版（しきい値ごとに rbind→split→集計）
}

# 安全版：しきい値ごとに「10回の結果を縦結合 → traitごとに cor_mean の mean/var」
summarize_over_repeats <- function(summary_list) {
  lapply(summary_list, function(rep_list) {
    # rep_list は長さ10の list（各要素は data.frame: trait, cor_mean, cor_var）
    df <- do.call(rbind, lapply(seq_along(rep_list), function(r) {
      cbind(rep = r, rep_list[[r]])
    }))
    # traitごとに cor_mean の平均・分散
    agg <- do.call(rbind, lapply(split(df, df$trait), function(dd) {
      data.frame(
        trait         = unique(dd$trait),
        cor_mean_mean = mean(dd$cor_mean, na.rm = TRUE),
        cor_mean_var  = var(dd$cor_mean,  na.rm = TRUE),
        cor_var_mean  = mean(dd$cor_var,  na.rm = TRUE),  # 参考：各rep内の var の平均
        n_rep         = nrow(dd)
      )
    }))
    rownames(agg) <- NULL
    agg
  })
}

cor_fixed_summary10 <- summarize_over_repeats(cor_summary_fixed)
cor_rand_summary10  <- summarize_over_repeats(cor_summary_rand)

## ========= 保存 =========
saveRDS(
  list(
    per_repeat = list(fixed = cor_summary_fixed, rand = cor_summary_rand),
    summary10  = list(fixed = cor_fixed_summary10, rand = cor_rand_summary10)
  ),
  here::here("out", paste0("rainbow_cor_summary_",model, CD, "percent.rds"))
)

# # 必要ならCSV（しきい値ごとに）
# dir.create(here::here("out", "rainbow_cor_csv", CD), recursive = TRUE, showWarnings = FALSE)
# for (per in thresholds) {
#   if (!is.null(cor_fixed_summary10[[per]]))
#     write.csv(cor_fixed_summary10[[per]],
#               here::here("out", "rainbow_cor_csv", CD, paste0("fixed_", per, ".csv")),
#               row.names = FALSE)
#   if (!is.null(cor_rand_summary10[[per]]))
#     write.csv(cor_rand_summary10[[per]],
#               here::here("out", "rainbow_cor_csv", CD, paste0("rand_", per, ".csv")),
#               row.names = FALSE)
# }


}

}

```



mmemo2

```{, message =F, include=FALSE}
ite<-1
res_list_thr<-list()
for (amat in met2_sub_cov_bundle$covs){
  
print(ite)
t<-paste0("per",names(met2_sub_cov_bundle$covs)[ite])

#Predict WHAT by RAINBOWR
y <- pheno.sel.cd 
var.pheno.all = c() #traitごと結果(要約)
reslist <- list() #traitごと結果

amatZ <- design.Z(pheno.labels = rownames(pheno.sel.cd),
                  geno.names = rownames(amat))
amatList <- list(Z = amatZ,
                 K = amat)
ZETA <- list(amat = amatList)
X0 <- NULL

# set the seed and cross-validation index
rep5 <- rep(1:5, 1000)
rep5 <- rep5[1:nrow(y)]

for (i in 2:ncol(y)){
#for (i in 2){  
trait.name <- colnames(y)[i]
print(c(i,"/",ncol(y)))
print(trait.name)
# make the case for the result
resultIndex <- c("Correlation", "R2", "RMSE","varU","varE","h2")
resultEachSeed <- matrix(NA, ncol = length(resultIndex), nrow = length(seedInd))
colnames(resultEachSeed) <- resultIndex
rownames(resultEachSeed) <- seedInd

for (seedIndEach in 1:length(seedInd)) {
  # seedIndEach <- 1
  set.seed(seedInd[seedIndEach])
  crossCvInd <- sample(rep5, nrow(y), replace = F)
  
  # prepare the prediction box
  predictionDataRAINBOW <- rep(NA, nrow(y))
  for (times in 1:5) {
    # times <- 1
    testInd <- crossCvInd == times
    yNa <- y[,i]
    yNa[testInd] <- NA
    
    # RAINBOWR
    resEM3 <- EM3.cpp(y = yNa,
                      X0 = X0, n.core = 1, 
                      ZETA = ZETA)
    
    # input the predicted data
    predictionDataRAINBOW[testInd] <- resEM3$y.pred[testInd]
  }
  
  # resEM3$weights
  predictData <- (predictionDataRAINBOW)
  obsData <- (y[,i])
  
  # calculate the R2 and RMSE
  correlation <- cor(obsData, predictData)
  R2 <- 1 - sum((obsData - predictData) ^ 2) / sum((obsData - mean(obsData)) ^ 2)
  RMSE <- sqrt(sum((obsData - predictData) ^ 2) / length(obsData))
  VU <- resEM3$Vu
  VE <- resEM3$Ve
  h2 <-  VU/(VU+VE)

  # input the result
  resultEachSeed[seedIndEach, ] <- c(correlation, R2, RMSE,VU,VE,h2)
}

resultsum<- apply(resultEachSeed, 2, mean)
resultsum<- as.matrix(resultsum)
colnames(resultsum) <-trait.name
reslist[[i]]<- resultEachSeed
#write.csv(resultEachSeed, here("out/pheno", paste0(trait.name, "_rainb.csv" )))

var.pheno.all <- cbind(var.pheno.all,resultsum)

}

rownames(var.pheno.all) <- resultIndex

res_list_thr[[t]]<-var.pheno.all

ite<- ite + 1
}


write.csv(res_list_thr, here("out", paste0("var_pheno_2019_,",CD,"_rainb_thr.csv" )))


```
