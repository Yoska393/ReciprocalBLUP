---
title: "b1_histgram"
author: "Hayato Yoshioka"
date: "2025-10-15"
output: html_document
---
```{r}
library(here)
library(magick)
```



```{r}
# ===== Full script: 8 histograms (4 directions x 2 groups) per CD =====
suppressMessages({
  library(here)
  library(dplyr)
})

# Output folder
dir.create(here("out/hist"), recursive = TRUE, showWarnings = FALSE)

# Colors by group
col_drought <- "#E69F00"  # Drought = orange
col_control <- "#0072B2"  # Control = blue

# PNG device (use ragg if available)
open_png <- function(path, width=700, height=540, res=150){
  dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
  if (requireNamespace("ragg", quietly = TRUE)) {
    ragg::agg_png(path, width=width, height=height, res=res)
  } else {
    png(path, width=width, height=height, res=res)
  }
}

# Pick the first existing file among candidates
pick_existing <- function(candidates) {
  for (fn in candidates) if (file.exists(fn)) return(fn)
  stop("None of the candidate files exist:\n", paste0(" - ", candidates, collapse = "\n"))
}

# Read → matrix → transpose → data.frame → select columns 1,2,3,6 (if present)
read_and_prepare <- function(direction = c("G->Micro","G->Met","Micro->Met","Met->Micro"), CD){
  direction <- match.arg(direction)

  # Build candidate filenames depending on direction
  candidates <- switch(direction,
    "G->Micro"   = c(
      here("out/herit", paste0("var_com_2019_", CD, "_rainb.csv"))
    ),
    "G->Met"     = c(
      here("out/herit", paste0("var_met_2019_", CD, "_rainb.csv"))
    ),
    "Micro->Met" = c(
      here("out/herit", paste0("var_met_2019_mrm", CD, "_rainb.csv"))#,
      #here("out/herit", paste0("var_met_2019_", CD, "_rainb.csv")) # fallback
    ),
    "Met->Micro" = c(
      here("out/herit", paste0("var_com_2019_metrm", CD, "_rainb.csv"))#,
      #here("out/herit", paste0("var_com_2019_", CD, "_rainb.csv")) # fallback
    )
  )

  fn <- pick_existing(candidates)
  message("Reading: ", fn)

  dat <- read.csv(fn, row.names = 1, check.names = FALSE)
  dat <- as.data.frame(t(as.matrix(dat)))

  keep <- intersect(c(1,2,3,6), seq_len(ncol(dat)))
  if (length(keep) == 0) stop("No target columns (1,2,3,6) exist in: ", fn)

  dplyr::select(dat, all_of(keep))
}

# Decide "kind" for y-limit by direction
kind_from_direction <- function(direction) {
  # micro-kind → uses micro y-limit (0–400), met-kind → 0–70
  if (direction %in% c("G->Micro","Met->Micro")) return("micro")
  if (direction %in% c("G->Met","Micro->Met"))   return("met")
  stop("Unknown direction: ", direction)
}

# Single histogram for the first column
plot_hist_firstcol <- function(df, title, out_png,
                               kind = c("micro","met"),
                               group = c("drought","control"),
                               breaks = seq(-0.5, 1.0, 0.03),
                               add_legend = FALSE,
                               ylim = NULL){

  kind  <- match.arg(kind)
  group <- match.arg(group)

  # Color by group
  col <- if (group == "drought") col_drought else col_control

  # Default y-limits
  if (is.null(ylim)) {
    ylim <- if (kind == "met") c(0, 70) else c(0, 460)
  }

  x <- df[[1]]
  x <- x[is.finite(x)]

  open_png(out_png, width = 700, height = 540, res = 150)
  par(mar=c(4.2,4.2,2.8,1))
  hist(x,
       breaks = breaks,
       main   = title,
       xlab   = "COR", ylab = "Count",
       cex.main = 1.45, cex.lab = 1.2, cex.axis = 1.05,
       col = col, border = "#333333",
       ylim = ylim)
  if (add_legend){
    legend("topright",
           legend = c("Drought","Control"),
           fill = c(col_drought, col_control),
           border = NA, bty = "n", cex = 1.0)
  }
  box(lwd=1)
  dev.off()
}

# ===== Configure which CDs belong to which group =====
# Example: W1 = Drought, W4 = Control  → produces 8 plots total (4 directions × 2 CDs)
CDs    <- c("W4","W1")
groups <- c("drought","control")  # lowercase for internal use

stopifnot(length(CDs) == length(groups))
stopifnot(all(groups %in% c("drought","control")))

# Directions to generate (ordered)
directions <- c("G->Met", "G->Micro", "Micro->Met", "Met->Micro")

# ===== Batch generate =====
for (i in seq_along(CDs)){
  cd <- CDs[i]
  gp <- groups[i]
  gp_label <- if (gp=="drought") "Drought" else "Control"  # only used if you want it in the title

  for (dirn in directions){
    df   <- read_and_prepare(dirn, cd)
    kind <- kind_from_direction(dirn)

    # Title exactly like: "Met->Micro (CD)"
    title <- paste0(dirn, " (", gp, ")")

    out_file <- here("out/hist", paste0("hist_", gsub("[-> ]","", dirn), "_", cd, "_", gp, ".png"))
    plot_hist_firstcol(
      df,
      title   = title,
      out_png = out_file,
      kind    = kind,
      group   = gp,
      add_legend = TRUE
    )
  }
}

# ===== Output examples =====
# out/hist/hist_GMicro_W1_drought.png       # "G->Micro (W1)"
# out/hist/hist_GMet_W1_drought.png         # "G->Met (W1)"
# out/hist/hist_MicroMet_W1_drought.png     # "Micro->Met (W1)"
# out/hist/hist_MetMicro_W1_drought.png     # "Met->Micro (W1)"
# ... and similarly for W4_control

```



```{r}

CDs    <- c("W4","W1")
groups <- c("drought","control")

token_from_dir <- function(dirn) switch(dirn,
  "G->Micro"="GMicro","G->Met"="GMet","Micro->Met"="MicroMet","Met->Micro"="MetMicro")

fpath <- function(dirn, cd, gp) {
  tok <- token_from_dir(dirn)
  here("out/hist", paste0("hist_", tok, "_", cd, "_", gp, ".png"))
}

col_dirs  <- c("G->Micro", "G->Micro", "G->Met", "G->Met")
row2_dirs <- c("Met->Micro","Met->Micro","Micro->Met","Micro->Met")

cd_col <- c(CDs[1], CDs[2], CDs[1], CDs[2])
gp_col <- c(groups[1], groups[2], groups[1], groups[2])

# Helper: read & force same size (avoid append errors)
read_resize <- function(path, w=700, h=540) image_resize(image_read(path), paste0(w,"x",h,"!"))

# Row 1
row1_paths <- mapply(fpath, col_dirs, cd_col, gp_col, SIMPLIFY=TRUE)
stopifnot(all(file.exists(row1_paths)))
row1 <- image_append(image_join(lapply(row1_paths, read_resize)), stack = FALSE)

# Row 2
row2_paths <- mapply(fpath, row2_dirs, cd_col, gp_col, SIMPLIFY=TRUE)
stopifnot(all(file.exists(row2_paths)))
row2 <- image_append(image_join(lapply(row2_paths, read_resize)), stack = FALSE)

# Stack rows
panel <- image_append(c(row1, row2), stack = TRUE)

image_write(panel, here("out/hist","panel_2x4.png"))

```

```{r}
suppressMessages({
  library(ggplot2)
})

label_order_micro <- c("G->Micro (D)","Met->Micro (D)","G->Micro (C)","Met->Micro (C)")
label_order_met   <- c("G->Met (D)","Micro->Met (D)","G->Met (C)","Micro->Met (C)")

dirs_by_kind <- list(micro = c("G->Micro","Met->Micro"),
                     met   = c("G->Met","Micro->Met"))

make_label <- function(dirn, group){
  if (group == "drought") paste0(dirn, " (D)") else paste0(dirn, " (C)")
}

build_matrix_df <- function(kind, CDs, groups){
  dirvec <- dirs_by_kind[[kind]]
  label_order <- if (kind == "micro") label_order_micro else label_order_met
  cols <- list()
  for (dirn in dirvec){
    for (i in seq_along(CDs)){
      cd <- CDs[i]; gp <- groups[i]
      df <- read_and_prepare(dirn, cd)
      x  <- df[[1]]; x <- x[is.finite(x)]
      lbl <- make_label(dirn, gp)
      cols[[lbl]] <- x
    }
  }
  maxlen <- max(vapply(cols, length, integer(1)))
  pad_to <- function(x, n) if (length(x) >= n) x[1:n] else c(x, rep(NA_real_, n - length(x)))
  mat <- vapply(cols, pad_to, numeric(maxlen), n = maxlen)
  dat <- as.data.frame(mat, check.names = FALSE)
  dat[, label_order, drop = FALSE]
}

to_pairs_long <- function(dat, label_order){
  vars <- label_order
  out_list <- list(); k <- 1L
  rng_common <- range(unlist(dat), finite = TRUE)
  mid <- mean(rng_common)
  for (iy in seq_along(vars)){      # row (y)
    for (ix in seq_along(vars)){    # col (x)
      vx <- vars[ix]; vy <- vars[iy]
      x <- dat[[vx]]; y <- dat[[vy]]
      panel_type <- if (iy < ix) "upper" else if (iy == ix) "diag" else "lower"
      out_list[[k]] <- data.frame(
        x = x, y = y,
        var_x = factor(vx, levels = vars),
        var_y = factor(vy, levels = vars),
        panel = panel_type,
        stringsAsFactors = FALSE
      ); k <- k + 1L
    }
  }
  pairs_df <- do.call(rbind, out_list)

  # 相関計算（上三角）
  upper_pairs <- subset(pairs_df, panel == "upper")
  if (nrow(upper_pairs) > 0){
    combos <- unique(upper_pairs[c("var_x","var_y")])
    corr_df <- within(combos, {
      label <- mapply(function(vx, vy){
        cx <- dat[[as.character(vx)]]
        cy <- dat[[as.character(vy)]]
        r  <- suppressWarnings(cor(cx, cy, use = "pairwise.complete.obs"))
        sprintf("COR=%.2f", r)   # ★ ここを修正
      }, var_x, var_y)
      xpos <- mid
      ypos <- mid
    })
  } else {
    corr_df <- data.frame(
      var_x=factor(),
      var_y=factor(),
      label=character(),
      xpos=numeric(),
      ypos=numeric()
    )
  }

  list(pairs_df = pairs_df, corr_df = corr_df, rng = rng_common)
}

plot_pairs_ggplot <- function(pairs_df, corr_df, rng, title = NULL){
  # 下三角のパネルだけ
  df_lower <- subset(pairs_df, panel == "lower")[, c("var_x","var_y")]
  df_lower <- unique(df_lower)
  df_lower <- droplevels(df_lower)

  # 各下三角パネル用の y = x 線データを作成
  df_line <- do.call(rbind, lapply(seq_len(nrow(df_lower)), function(i){
    vx <- df_lower$var_x[i]
    vy <- df_lower$var_y[i]
    data.frame(
      x = rng,
      y = rng,
      var_x = vx,
      var_y = vy
    )
  }))

  ggplot() +
    # 散布図（下三角）
    geom_point(
      data = subset(pairs_df, panel == "lower"),
      aes(x = x, y = y),
      size = 0.7, alpha = 0.5
    ) +
    # y = x 線（下三角のみ）
    geom_line(
      data = df_line,
      aes(x = x, y = y, group = interaction(var_x, var_y)),
      linetype = "dashed"
    ) +
    # 密度（対角）
    geom_density(
      data = subset(pairs_df, panel == "diag"),
      aes(x = x, y = after_stat(scaled) * diff(rng) + rng[1]),
      linewidth = 0.5
    ) +
    # 相関（上三角）
    geom_text(
      data = corr_df,
      aes(x = xpos, y = ypos, label = label),
      fontface = "bold"
    ) +
    facet_grid(var_y ~ var_x, scales = "fixed") +
    coord_equal(xlim = rng, ylim = rng, expand = FALSE) +
    labs(x = NULL, y = NULL, title = title) +
    theme_bw(base_size = 11) +
    theme(
      panel.grid  = element_blank(),
      plot.title  = element_text(hjust = 0.5, size = 18, face = "bold"),
      strip.text  = element_text(size = 10),
      axis.text   = element_text(size = 8)
    )
}



make_pairs_ggplot <- function(kind, CDs, groups, outdir = here("out/hist")){
  label_order <- if (kind == "micro") label_order_micro else label_order_met
  dat <- build_matrix_df(kind, CDs, groups)
  conv <- to_pairs_long(dat, label_order)

  pairs_df <- conv$pairs_df
  corr_df  <- conv$corr_df
  rng      <- conv$rng   # ← kind別の range を使う！

　pad <- diff(rng) * 0.05   # 10%余白
　rng <- c(rng[1] - pad, rng[2] + pad)

  out_file <- here(outdir, paste0("pairs_", kind, "_ggplot.png"))
  open_png(out_file, width = 1200, height = 1200, res = 150)

   plot_title <- if (kind == "micro") {
    "Microbiome Prediction"
  } else {
    "Metabolome Prediction"
  }
   
  p <- plot_pairs_ggplot(
    pairs_df, corr_df, rng,
    title = plot_title
  )
  print(p)
  dev.off()
}
make_pairs_ggplot("micro", CDs, groups)
make_pairs_ggplot("met", CDs, groups)
```


```{r}
suppressMessages({
  library(ggplot2)
  library(ggh4x)
})

label_order_micro <- c("G->Micro (D)","Met->Micro (D)","G->Micro (C)","Met->Micro (C)")
label_order_met   <- c("G->Met (D)","Micro->Met (D)","G->Met (C)","Micro->Met (C)")

dirs_by_kind <- list(
  micro = c("G->Micro","Met->Micro"),
  met   = c("G->Met","Micro->Met")
)

make_label <- function(dirn, group){
  if (group == "drought") paste0(dirn, " (D)") else paste0(dirn, " (C)")
}

build_matrix_df <- function(kind, CDs, groups){
  dirvec <- dirs_by_kind[[kind]]
  label_order <- if (kind == "micro") label_order_micro else label_order_met
  cols <- list()
  for (dirn in dirvec){
    for (i in seq_along(CDs)){
      cd <- CDs[i]; gp <- groups[i]
      df <- read_and_prepare(dirn, cd)
      x  <- df[[1]]; x <- x[is.finite(x)]
      lbl <- make_label(dirn, gp)
      cols[[lbl]] <- x
    }
  }
  maxlen <- max(vapply(cols, length, integer(1)))
  pad_to <- function(x, n) if (length(x) >= n) x[1:n] else c(x, rep(NA_real_, n - length(x)))
  mat <- vapply(cols, pad_to, numeric(maxlen), n = maxlen)
  dat <- as.data.frame(mat, check.names = FALSE)
  dat[, label_order, drop = FALSE]
}

to_pairs_long <- function(dat, label_order){
  vars <- label_order
  out_list <- list(); k <- 1L
  rng_common <- range(unlist(dat), finite = TRUE)
  mid <- mean(rng_common)
  for (iy in seq_along(vars)){
    for (ix in seq_along(vars)){
      vx <- vars[ix]; vy <- vars[iy]
      x <- dat[[vx]]; y <- dat[[vy]]
      panel_type <- if (iy < ix) "upper" else if (iy == ix) "diag" else "lower"
      out_list[[k]] <- data.frame(
        x = x, y = y,
        var_x = factor(vx, levels = vars),
        var_y = factor(vy, levels = vars),
        panel = panel_type,
        stringsAsFactors = FALSE
      ); k <- k + 1L
    }
  }
  pairs_df <- do.call(rbind, out_list)

  upper_pairs <- subset(pairs_df, panel == "upper")
  if (nrow(upper_pairs) > 0){
    combos <- unique(upper_pairs[c("var_x","var_y")])
    corr_df <- within(combos, {
      label <- mapply(function(vx, vy){
        cx <- dat[[as.character(vx)]]
        cy <- dat[[as.character(vy)]]
        r  <- suppressWarnings(cor(cx, cy, use = "pairwise.complete.obs"))
        sprintf("COR=%.2f", r)
      }, var_x, var_y)
      xpos <- mid
      ypos <- mid
    })
  } else {
    corr_df <- data.frame(
      var_x=factor(),
      var_y=factor(),
      label=character(),
      xpos=numeric(),
      ypos=numeric()
    )
  }

  list(pairs_df = pairs_df, corr_df = corr_df, rng = rng_common)
}

plot_pairs_ggplot <- function(pairs_df, corr_df, rng, title = NULL){
  # strip 背景色: (C)→#0072B2, (D)→#E69F00
  strip_cols <- setNames(
  ifelse(grepl("\\(C\\)", levels(pairs_df$var_x)), "#0072B266", "#F1B43C"),
  levels(pairs_df$var_x)
)



  df_lower <- subset(pairs_df, panel == "lower")[, c("var_x","var_y")]
  df_lower <- unique(df_lower)
  df_lower <- droplevels(df_lower)

  df_line <- do.call(rbind, lapply(seq_len(nrow(df_lower)), function(i){
    vx <- df_lower$var_x[i]
    vy <- df_lower$var_y[i]
    data.frame(x = rng, y = rng, var_x = vx, var_y = vy)
  }))

  diag_df <- subset(pairs_df, panel == "diag")
  diag_df$grp <- ifelse(grepl("\\(C\\)", as.character(diag_df$var_x)), "C", "D")

  ggplot() +
    geom_point(
      data = subset(pairs_df, panel == "lower"),
      aes(x = x, y = y),
      size = 0.7, alpha = 0.5
    ) +
    geom_line(
      data = df_line,
      aes(x = x, y = y, group = interaction(var_x, var_y)),
      linetype = "dashed"
    ) +
    geom_density(
      data = diag_df,
      aes(x = x, y = after_stat(scaled) * diff(rng) + rng[1], color = grp),
      linewidth = 0.5,
      show.legend = FALSE
    ) +
    geom_text(
      data = corr_df,
      aes(x = xpos, y = ypos, label = label),
      fontface = "bold"
    ) +
    # ★ ここを facet_grid2 に変更し、strip= を指定
    # ★ ここを facet_grid2 に変更し、strip= を指定
ggh4x::facet_grid2(
  rows = vars(var_y),
  cols = vars(var_x),
  scales = "fixed",
  strip = ggh4x::strip_themed(
    background_x = lapply(levels(pairs_df$var_x), function(v) {
      element_rect(fill = strip_cols[[v]], colour = NA)
    }),
    background_y = lapply(levels(pairs_df$var_y), function(v) {
      element_rect(fill = strip_cols[[v]], colour = NA)
    }),
    text_x = lapply(levels(pairs_df$var_x), function(v) {
      element_text(colour = "black", face = "bold", size = 10)
    }),
    text_y = lapply(levels(pairs_df$var_y), function(v) {
      element_text(colour = "black", face = "bold", size = 10)
    })
  ),
  switch = "y"  # ← y側のストリップを左に移す
) +
    coord_equal(xlim = rng, ylim = rng, expand = FALSE) +
    labs(x = NULL, y = NULL, title = title) +
    theme_bw(base_size = 11) +
    theme(
      panel.grid  = element_blank(),
      plot.title  = element_text(hjust = 0.5, size = 18, face = "bold"),
      strip.text  = element_text(size = 10),  # 文字は黒で統一
      axis.text   = element_text(size = 8)
    ) +
    scale_color_manual(values = c(C = "black", D = "black"))
  
}


make_pairs_ggplot <- function(kind, CDs, groups, outdir = here("out/hist")){
  label_order <- if (kind == "micro") label_order_micro else label_order_met
  dat <- build_matrix_df(kind, CDs, groups)
  conv <- to_pairs_long(dat, label_order)

  pairs_df <- conv$pairs_df
  corr_df  <- conv$corr_df
  rng      <- conv$rng

  pad <- diff(rng) * 0.05
  rng <- c(rng[1] - pad, rng[2] + pad)

  out_file <- here(outdir, paste0("pairs_", kind, "_ggplot.png"))
  open_png(out_file, width = 1200, height = 1200, res = 150)

  plot_title <- if (kind == "micro") "Microbiome Prediction" else "Metabolome Prediction"

  p <- plot_pairs_ggplot(pairs_df, corr_df, rng, title = plot_title)
  print(p)
  dev.off()
}

# 実行
make_pairs_ggplot("micro", CDs, groups)
make_pairs_ggplot("met", CDs, groups)

```

